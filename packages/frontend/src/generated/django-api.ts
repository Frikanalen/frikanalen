/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Frikanalen Django API
 * API for Frikanalen
 * OpenAPI spec version: 1.1.0
 */
import axios from "axios";
import type { AxiosRequestConfig, AxiosResponse } from "axios";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

export interface AsRun {
  readonly id: number;
  /**
   * Points to the Video which was played if there is one. Can be empty if something other than a video was played. The field is mutually exclusive with `programName`.
   * @nullable
   */
  video?: number | null;
  /**
   * A free form text input saying what was played. If `video` is set, this field should not be set. Examples of where you'd use this field is e.g. when broadcasting live. Defaults to the empty string.
   * @maxLength 160
   */
  programName?: string;
  /**
   * The playout this entry corresponds with. This will almost always be 'main' which it defaults to.
   * @maxLength 255
   */
  playout?: string;
  /** Time when the playout started. Defaults to now. */
  playedAt?: string;
  /**
   * The inpoint where the video/stream was started at. In milliseconds. Normally 0 which it defaults to.
   * @minimum -2147483648
   * @maximum 2147483647
   */
  inMs?: number;
  /**
   * The outpoint where the video/stream stopped. This would often be the duration of the video, or how long we live streamed a particular URL. Can be null (None) if this is 'currently happening'.
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  outMs?: number | null;
}

export interface Bulletin {
  readonly id: number;
  /** @maxLength 80 */
  heading: string;
  text: string;
  readonly created: string;
}

export interface Category {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id: number;
  /** @maxLength 255 */
  name: string;
  /** @maxLength 255 */
  desc?: string;
  readonly videocount: string;
}

export interface NewUser {
  readonly id: number;
  /** @maxLength 254 */
  email: string;
  firstName: string;
  lastName: string;
  dateOfBirth: string;
  password: string;
}

export interface Organization {
  readonly id: number;
  /** @maxLength 255 */
  name: string;
  /**
   * @maxLength 255
   * @nullable
   */
  homepage?: string | null;
  /** @maxLength 255 */
  description?: string;
  /**
   * @maxLength 2048
   * @nullable
   */
  postalAddress?: string | null;
  /**
   * @maxLength 2048
   * @nullable
   */
  streetAddress?: string | null;
  /** @nullable */
  readonly editorId: number | null;
  readonly editorName: string;
  readonly editorEmail: string;
  readonly editorMsisdn: string;
  readonly fkmember: boolean;
}

export interface PaginatedAsRunList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: AsRun[];
}

export interface PaginatedCategoryList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Category[];
}

export interface PaginatedOrganizationList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Organization[];
}

export interface PaginatedScheduleitemReadList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: ScheduleitemRead[];
}

export interface PaginatedVideoFileList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: VideoFile[];
}

export interface PaginatedVideoList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Video[];
}

export interface PatchedAsRun {
  readonly id?: number;
  /**
   * Points to the Video which was played if there is one. Can be empty if something other than a video was played. The field is mutually exclusive with `programName`.
   * @nullable
   */
  video?: number | null;
  /**
   * A free form text input saying what was played. If `video` is set, this field should not be set. Examples of where you'd use this field is e.g. when broadcasting live. Defaults to the empty string.
   * @maxLength 160
   */
  programName?: string;
  /**
   * The playout this entry corresponds with. This will almost always be 'main' which it defaults to.
   * @maxLength 255
   */
  playout?: string;
  /** Time when the playout started. Defaults to now. */
  playedAt?: string;
  /**
   * The inpoint where the video/stream was started at. In milliseconds. Normally 0 which it defaults to.
   * @minimum -2147483648
   * @maximum 2147483647
   */
  inMs?: number;
  /**
   * The outpoint where the video/stream stopped. This would often be the duration of the video, or how long we live streamed a particular URL. Can be null (None) if this is 'currently happening'.
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  outMs?: number | null;
}

export interface PatchedBulletin {
  readonly id?: number;
  /** @maxLength 80 */
  heading?: string;
  text?: string;
  readonly created?: string;
}

export interface PatchedCategory {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /** @maxLength 255 */
  name?: string;
  /** @maxLength 255 */
  desc?: string;
  readonly videocount?: string;
}

export interface PatchedOrganization {
  readonly id?: number;
  /** @maxLength 255 */
  name?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  homepage?: string | null;
  /** @maxLength 255 */
  description?: string;
  /**
   * @maxLength 2048
   * @nullable
   */
  postalAddress?: string | null;
  /**
   * @maxLength 2048
   * @nullable
   */
  streetAddress?: string | null;
  /** @nullable */
  readonly editorId?: number | null;
  readonly editorName?: string;
  readonly editorEmail?: string;
  readonly editorMsisdn?: string;
  readonly fkmember?: boolean;
}

export interface PatchedScheduleitemRead {
  readonly id?: number;
  video?: ScheduleitemVideo;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  schedulereason?: SchedulereasonEnum;
  starttime?: string;
  readonly endtime?: string;
  duration?: string;
}

export interface PatchedUser {
  readonly id?: number;
  readonly email?: string;
  /** @maxLength 30 */
  firstName?: string;
  /** @maxLength 30 */
  lastName?: string;
  readonly dateJoined?: string;
  readonly isStaff?: string;
  /** @nullable */
  dateOfBirth?: string | null;
  /**
   * Phone number at which this user can be reached
   * @maxLength 128
   */
  phoneNumber?: string;
  readonly organizationRoles?: string;
  password?: string;
}

export interface PatchedVideo {
  readonly id?: number;
  /** @maxLength 255 */
  name?: string;
  /**
   * @maxLength 2048
   * @nullable
   */
  header?: string | null;
  /**
   * @maxLength 2048
   * @nullable
   */
  description?: string | null;
  readonly files?: string;
  creator?: string;
  readonly organization?: Organization;
  duration?: string;
  categories?: string[];
  /** Framerate of master video in thousands / second */
  readonly framerate?: number;
  properImport?: boolean;
  hasTonoRecords?: boolean;
  publishOnWeb?: boolean;
  /** You still have the editorial responsibility.  Only affect videos from members. */
  isFiller?: boolean;
  /**
   * URL for reference
   * @maxLength 1024
   */
  refUrl?: string;
  /**
   * Time the program record was created
   * @nullable
   */
  readonly createdTime?: string | null;
  /**
   * Time the program record has been updated
   * @nullable
   */
  readonly updatedTime?: string | null;
  /**
   * Time the original video for the program was uploaded
   * @nullable
   */
  uploadedTime?: string | null;
  readonly ogvUrl?: string;
  readonly largeThumbnailUrl?: string;
}

export interface PatchedVideoFile {
  readonly id?: number;
  video?: number;
  format?: number;
  /** @maxLength 256 */
  filename?: string;
  /**
   * Time the video file was created
   * @nullable
   */
  readonly createdTime?: string | null;
  /** @nullable */
  integratedLufs?: number | null;
  /** @nullable */
  truepeakLufs?: number | null;
}

export interface ScheduleitemModify {
  readonly id: number;
  /** @nullable */
  video?: number | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  schedulereason?: SchedulereasonEnum;
  starttime: string;
  readonly endtime: string;
  duration: string;
}

export interface ScheduleitemRead {
  readonly id: number;
  video: ScheduleitemVideo;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  schedulereason?: SchedulereasonEnum;
  starttime: string;
  readonly endtime: string;
  duration: string;
}

export interface ScheduleitemVideo {
  readonly id: number;
  /** @maxLength 255 */
  name: string;
  /**
   * @maxLength 2048
   * @nullable
   */
  header?: string | null;
  /**
   * @maxLength 2048
   * @nullable
   */
  description?: string | null;
  creator?: string;
  readonly organization: Organization;
  duration?: string;
  categories: string[];
}

/**
 * * `1` - Legacy
 * `2` - Administrative
 * `3` - User
 * `4` - Automatic
 * `5` - Jukebox
 */
export type SchedulereasonEnum =
  (typeof SchedulereasonEnum)[keyof typeof SchedulereasonEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchedulereasonEnum = {
  NUMBER_1: 1,
  NUMBER_2: 2,
  NUMBER_3: 3,
  NUMBER_4: 4,
  NUMBER_5: 5,
} as const;

export interface Token {
  readonly created: string;
  /** @maxLength 40 */
  key: string;
  user: number;
}

export interface User {
  readonly id: number;
  readonly email: string;
  /** @maxLength 30 */
  firstName?: string;
  /** @maxLength 30 */
  lastName?: string;
  readonly dateJoined: string;
  readonly isStaff: string;
  /** @nullable */
  dateOfBirth?: string | null;
  /**
   * Phone number at which this user can be reached
   * @maxLength 128
   */
  phoneNumber?: string;
  readonly organizationRoles: string;
  password?: string;
}

export interface Video {
  readonly id: number;
  /** @maxLength 255 */
  name: string;
  /**
   * @maxLength 2048
   * @nullable
   */
  header?: string | null;
  /**
   * @maxLength 2048
   * @nullable
   */
  description?: string | null;
  readonly files: string;
  creator?: string;
  readonly organization: Organization;
  duration?: string;
  categories: string[];
  /** Framerate of master video in thousands / second */
  readonly framerate: number;
  properImport?: boolean;
  hasTonoRecords?: boolean;
  publishOnWeb?: boolean;
  /** You still have the editorial responsibility.  Only affect videos from members. */
  isFiller?: boolean;
  /**
   * URL for reference
   * @maxLength 1024
   */
  refUrl?: string;
  /**
   * Time the program record was created
   * @nullable
   */
  readonly createdTime: string | null;
  /**
   * Time the program record has been updated
   * @nullable
   */
  readonly updatedTime: string | null;
  /**
   * Time the original video for the program was uploaded
   * @nullable
   */
  uploadedTime?: string | null;
  readonly ogvUrl: string;
  readonly largeThumbnailUrl: string;
}

export interface VideoCreate {
  readonly id: number;
  /** @maxLength 255 */
  name: string;
  /**
   * @maxLength 2048
   * @nullable
   */
  header?: string | null;
  /**
   * @maxLength 2048
   * @nullable
   */
  description?: string | null;
  readonly files: string;
  creator?: string;
  organization?: number;
  duration?: string;
  categories: string[];
  /** Framerate of master video in thousands / second */
  readonly framerate: number;
  properImport?: boolean;
  hasTonoRecords?: boolean;
  publishOnWeb?: boolean;
  /** You still have the editorial responsibility.  Only affect videos from members. */
  isFiller?: boolean;
  /**
   * URL for reference
   * @maxLength 1024
   */
  refUrl?: string;
  /**
   * Time the program record was created
   * @nullable
   */
  readonly createdTime: string | null;
  /**
   * Time the program record has been updated
   * @nullable
   */
  readonly updatedTime: string | null;
  /**
   * Time the original video for the program was uploaded
   * @nullable
   */
  uploadedTime?: string | null;
  readonly ogvUrl: string;
  readonly largeThumbnailUrl: string;
}

export interface VideoFile {
  readonly id: number;
  video: number;
  format: number;
  /** @maxLength 256 */
  filename: string;
  /**
   * Time the video file was created
   * @nullable
   */
  readonly createdTime: string | null;
  /** @nullable */
  integratedLufs?: number | null;
  /** @nullable */
  truepeakLufs?: number | null;
}

export interface VideoUploadToken {
  /**
   * Video upload token (used by fkupload/frontend)
   * @maxLength 32
   */
  uploadToken?: string;
  readonly uploadUrl: string;
}

export type AsrunListParams = {
  /**
   * Number of results to return per page.
   */
  limit?: number;
  /**
   * The initial index from which to return the results.
   */
  offset?: number;
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type CategoriesListParams = {
  /**
   * Number of results to return per page.
   */
  limit?: number;
  /**
   * The initial index from which to return the results.
   */
  offset?: number;
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type NewsBulletinsListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type OrganizationListParams = {
  /**
   * Number of results to return per page.
   */
  limit?: number;
  /**
   * The initial index from which to return the results.
   */
  offset?: number;
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type ScheduleitemsListParams = {
  /**
   * Number of results to return per page.
   */
  limit?: number;
  /**
   * The initial index from which to return the results.
   */
  offset?: number;
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type SchemaRetrieveParams = {
  format?: SchemaRetrieveFormat;
  lang?: SchemaRetrieveLang;
};

export type SchemaRetrieveFormat =
  (typeof SchemaRetrieveFormat)[keyof typeof SchemaRetrieveFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchemaRetrieveFormat = {
  json: "json",
  yaml: "yaml",
} as const;

export type SchemaRetrieveLang =
  (typeof SchemaRetrieveLang)[keyof typeof SchemaRetrieveLang];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchemaRetrieveLang = {
  af: "af",
  ar: "ar",
  "ar-dz": "ar-dz",
  ast: "ast",
  az: "az",
  be: "be",
  bg: "bg",
  bn: "bn",
  br: "br",
  bs: "bs",
  ca: "ca",
  ckb: "ckb",
  cs: "cs",
  cy: "cy",
  da: "da",
  de: "de",
  dsb: "dsb",
  el: "el",
  en: "en",
  "en-au": "en-au",
  "en-gb": "en-gb",
  eo: "eo",
  es: "es",
  "es-ar": "es-ar",
  "es-co": "es-co",
  "es-mx": "es-mx",
  "es-ni": "es-ni",
  "es-ve": "es-ve",
  et: "et",
  eu: "eu",
  fa: "fa",
  fi: "fi",
  fr: "fr",
  fy: "fy",
  ga: "ga",
  gd: "gd",
  gl: "gl",
  he: "he",
  hi: "hi",
  hr: "hr",
  hsb: "hsb",
  hu: "hu",
  hy: "hy",
  ia: "ia",
  id: "id",
  ig: "ig",
  io: "io",
  is: "is",
  it: "it",
  ja: "ja",
  ka: "ka",
  kab: "kab",
  kk: "kk",
  km: "km",
  kn: "kn",
  ko: "ko",
  ky: "ky",
  lb: "lb",
  lt: "lt",
  lv: "lv",
  mk: "mk",
  ml: "ml",
  mn: "mn",
  mr: "mr",
  ms: "ms",
  my: "my",
  nb: "nb",
  ne: "ne",
  nl: "nl",
  nn: "nn",
  os: "os",
  pa: "pa",
  pl: "pl",
  pt: "pt",
  "pt-br": "pt-br",
  ro: "ro",
  ru: "ru",
  sk: "sk",
  sl: "sl",
  sq: "sq",
  sr: "sr",
  "sr-latn": "sr-latn",
  sv: "sv",
  sw: "sw",
  ta: "ta",
  te: "te",
  tg: "tg",
  th: "th",
  tk: "tk",
  tr: "tr",
  tt: "tt",
  udm: "udm",
  ug: "ug",
  uk: "uk",
  ur: "ur",
  uz: "uz",
  vi: "vi",
  "zh-hans": "zh-hans",
  "zh-hant": "zh-hant",
} as const;

export type SchemaRetrieve200One = { [key: string]: unknown };

export type SchemaRetrieve200Two = { [key: string]: unknown };

export type SchemaRetrieve200Three = { [key: string]: unknown };

export type SchemaRetrieve200Four = { [key: string]: unknown };

export type SchemaFormattedRetrieveParams = {
  format?: SchemaFormattedRetrieveFormat;
  lang?: SchemaFormattedRetrieveLang;
};

export type SchemaFormattedRetrieveFormat =
  (typeof SchemaFormattedRetrieveFormat)[keyof typeof SchemaFormattedRetrieveFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchemaFormattedRetrieveFormat = {
  json: "json",
  yaml: "yaml",
} as const;

export type SchemaFormattedRetrieveLang =
  (typeof SchemaFormattedRetrieveLang)[keyof typeof SchemaFormattedRetrieveLang];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchemaFormattedRetrieveLang = {
  af: "af",
  ar: "ar",
  "ar-dz": "ar-dz",
  ast: "ast",
  az: "az",
  be: "be",
  bg: "bg",
  bn: "bn",
  br: "br",
  bs: "bs",
  ca: "ca",
  ckb: "ckb",
  cs: "cs",
  cy: "cy",
  da: "da",
  de: "de",
  dsb: "dsb",
  el: "el",
  en: "en",
  "en-au": "en-au",
  "en-gb": "en-gb",
  eo: "eo",
  es: "es",
  "es-ar": "es-ar",
  "es-co": "es-co",
  "es-mx": "es-mx",
  "es-ni": "es-ni",
  "es-ve": "es-ve",
  et: "et",
  eu: "eu",
  fa: "fa",
  fi: "fi",
  fr: "fr",
  fy: "fy",
  ga: "ga",
  gd: "gd",
  gl: "gl",
  he: "he",
  hi: "hi",
  hr: "hr",
  hsb: "hsb",
  hu: "hu",
  hy: "hy",
  ia: "ia",
  id: "id",
  ig: "ig",
  io: "io",
  is: "is",
  it: "it",
  ja: "ja",
  ka: "ka",
  kab: "kab",
  kk: "kk",
  km: "km",
  kn: "kn",
  ko: "ko",
  ky: "ky",
  lb: "lb",
  lt: "lt",
  lv: "lv",
  mk: "mk",
  ml: "ml",
  mn: "mn",
  mr: "mr",
  ms: "ms",
  my: "my",
  nb: "nb",
  ne: "ne",
  nl: "nl",
  nn: "nn",
  os: "os",
  pa: "pa",
  pl: "pl",
  pt: "pt",
  "pt-br": "pt-br",
  ro: "ro",
  ru: "ru",
  sk: "sk",
  sl: "sl",
  sq: "sq",
  sr: "sr",
  "sr-latn": "sr-latn",
  sv: "sv",
  sw: "sw",
  ta: "ta",
  te: "te",
  tg: "tg",
  th: "th",
  tk: "tk",
  tr: "tr",
  tt: "tt",
  udm: "udm",
  ug: "ug",
  uk: "uk",
  ur: "ur",
  uz: "uz",
  vi: "vi",
  "zh-hans": "zh-hans",
  "zh-hant": "zh-hant",
} as const;

export type SchemaFormattedRetrieve200One = { [key: string]: unknown };

export type SchemaFormattedRetrieve200Two = { [key: string]: unknown };

export type SchemaFormattedRetrieve200Three = { [key: string]: unknown };

export type SchemaFormattedRetrieve200Four = { [key: string]: unknown };

export type VideofilesListParams = {
  createdTimeAfter?: string;
  createdTimeBefore?: string;
  format_Fsname?: string;
  integratedLufs?: number;
  integratedLufs_Gt?: number;
  integratedLufs_Gte?: number;
  integratedLufs_Isnull?: boolean;
  integratedLufs_Lt?: number;
  integratedLufs_Lte?: number;
  /**
   * Number of results to return per page.
   */
  limit?: number;
  /**
   * The initial index from which to return the results.
   */
  offset?: number;
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
  truepeakLufs?: number;
  truepeakLufs_Gt?: number;
  truepeakLufs_Gte?: number;
  truepeakLufs_Isnull?: boolean;
  truepeakLufs_Lt?: number;
  truepeakLufs_Lte?: number;
};

export type VideosListParams = {
  categories_Name_Icontains?: string[];
  createdTimeAfter?: string;
  createdTimeBefore?: string;
  creator_Email?: string;
  duration?: string;
  duration_Gt?: string;
  duration_Gte?: string;
  duration_Lt?: string;
  duration_Lte?: string;
  framerate?: number;
  hasTonoRecords?: boolean;
  isFiller?: boolean;
  /**
   * Number of results to return per page.
   */
  limit?: number;
  name?: string;
  name_Icontains?: string;
  /**
   * The initial index from which to return the results.
   */
  offset?: number;
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
  organization?: number;
  playedCountWeb?: number;
  playedCountWeb_Gt?: number;
  playedCountWeb_Gte?: number;
  playedCountWeb_Lt?: number;
  playedCountWeb_Lte?: number;
  publishOnWeb?: boolean;
  refUrl?: string;
  refUrl_Icontains?: string;
  refUrl_Startswith?: string;
  updatedTimeAfter?: string;
  updatedTimeBefore?: string;
  uploadedTimeAfter?: string;
  uploadedTimeBefore?: string;
};

/**
 * The root of the FK API / web services
 */
export const rootRetrieve = <TData = AxiosResponse<void>>(
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/`, options);
};

/**
 * AsRun model is a historic log over what was sent through playout.

Query parameters
----------------

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - You can order the results by any visible field.
             Prepend a minus to order in descending order.  I.e.
             `?ordering=-played_at` to show newest items first.
 */
export const asrunList = <TData = AxiosResponse<PaginatedAsRunList>>(
  params?: AsrunListParams,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/asrun/`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

/**
 * AsRun model is a historic log over what was sent through playout.

Query parameters
----------------

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - You can order the results by any visible field.
             Prepend a minus to order in descending order.  I.e.
             `?ordering=-played_at` to show newest items first.
 */
export const asrunCreate = <TData = AxiosResponse<AsRun>>(
  asRun: NonReadonly<AsRun>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`http://localhost:8000/api/asrun/`, asRun, options);
};

/**
 * AsRun model is a historic log over what was sent through playout.

Query parameters
----------------

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - You can order the results by any visible field.
             Prepend a minus to order in descending order.  I.e.
             `?ordering=-played_at` to show newest items first.
 */
export const asrunRetrieve = <TData = AxiosResponse<AsRun>>(
  id: number,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/asrun/${id}/`, options);
};

/**
 * AsRun model is a historic log over what was sent through playout.

Query parameters
----------------

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - You can order the results by any visible field.
             Prepend a minus to order in descending order.  I.e.
             `?ordering=-played_at` to show newest items first.
 */
export const asrunUpdate = <TData = AxiosResponse<AsRun>>(
  id: number,
  asRun: NonReadonly<AsRun>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.put(`http://localhost:8000/api/asrun/${id}/`, asRun, options);
};

/**
 * AsRun model is a historic log over what was sent through playout.

Query parameters
----------------

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - You can order the results by any visible field.
             Prepend a minus to order in descending order.  I.e.
             `?ordering=-played_at` to show newest items first.
 */
export const asrunPartialUpdate = <TData = AxiosResponse<AsRun>>(
  id: number,
  patchedAsRun: NonReadonly<PatchedAsRun>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.patch(
    `http://localhost:8000/api/asrun/${id}/`,
    patchedAsRun,
    options,
  );
};

/**
 * AsRun model is a historic log over what was sent through playout.

Query parameters
----------------

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - You can order the results by any visible field.
             Prepend a minus to order in descending order.  I.e.
             `?ordering=-played_at` to show newest items first.
 */
export const asrunDestroy = <TData = AxiosResponse<void>>(
  id: number,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.delete(`http://localhost:8000/api/asrun/${id}/`, options);
};

export const categoriesList = <TData = AxiosResponse<PaginatedCategoryList>>(
  params?: CategoriesListParams,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/categories/`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const categoriesCreate = <TData = AxiosResponse<Category>>(
  category: NonReadonly<Category>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`http://localhost:8000/api/categories/`, category, options);
};

export const categoriesRetrieve = <TData = AxiosResponse<Category>>(
  id: number,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/categories/${id}/`, options);
};

export const categoriesUpdate = <TData = AxiosResponse<Category>>(
  id: number,
  category: NonReadonly<Category>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.put(
    `http://localhost:8000/api/categories/${id}/`,
    category,
    options,
  );
};

export const categoriesPartialUpdate = <TData = AxiosResponse<Category>>(
  id: number,
  patchedCategory: NonReadonly<PatchedCategory>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.patch(
    `http://localhost:8000/api/categories/${id}/`,
    patchedCategory,
    options,
  );
};

export const categoriesDestroy = <TData = AxiosResponse<void>>(
  id: number,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.delete(`http://localhost:8000/api/categories/${id}/`, options);
};

export const jukeboxCsvRetrieve = <TData = AxiosResponse<void>>(
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/jukebox_csv`, options);
};

export const newsBulletinsList = <TData = AxiosResponse<Bulletin[]>>(
  params?: NewsBulletinsListParams,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/news/bulletins/`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const newsBulletinsCreate = <TData = AxiosResponse<Bulletin>>(
  bulletin: NonReadonly<Bulletin>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(
    `http://localhost:8000/api/news/bulletins/`,
    bulletin,
    options,
  );
};

export const newsBulletinsRetrieve = <TData = AxiosResponse<Bulletin>>(
  id: number,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/news/bulletins/${id}/`, options);
};

export const newsBulletinsUpdate = <TData = AxiosResponse<Bulletin>>(
  id: number,
  bulletin: NonReadonly<Bulletin>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.put(
    `http://localhost:8000/api/news/bulletins/${id}/`,
    bulletin,
    options,
  );
};

export const newsBulletinsPartialUpdate = <TData = AxiosResponse<Bulletin>>(
  id: number,
  patchedBulletin: NonReadonly<PatchedBulletin>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.patch(
    `http://localhost:8000/api/news/bulletins/${id}/`,
    patchedBulletin,
    options,
  );
};

export const newsBulletinsDestroy = <TData = AxiosResponse<void>>(
  id: number,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.delete(
    `http://localhost:8000/api/news/bulletins/${id}/`,
    options,
  );
};

/**
 * Get a token you can use as a header instead of basic auth.

Use the header with HTTP like:
    Authorization: Token 000000000000...
 */
export const obtainTokenRetrieve = <TData = AxiosResponse<Token>>(
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/obtain-token`, options);
};

export const organizationList = <
  TData = AxiosResponse<PaginatedOrganizationList>,
>(
  params?: OrganizationListParams,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/organization/`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const organizationCreate = <TData = AxiosResponse<Organization>>(
  organization: NonReadonly<Organization>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(
    `http://localhost:8000/api/organization/`,
    organization,
    options,
  );
};

/**
 * Video file details
 */
export const organizationRetrieve = <TData = AxiosResponse<Organization>>(
  id: string,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/organization/${id}`, options);
};

/**
 * Video file details
 */
export const organizationUpdate = <TData = AxiosResponse<Organization>>(
  id: string,
  organization: NonReadonly<Organization>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.put(
    `http://localhost:8000/api/organization/${id}`,
    organization,
    options,
  );
};

/**
 * Video file details
 */
export const organizationPartialUpdate = <TData = AxiosResponse<Organization>>(
  id: string,
  patchedOrganization: NonReadonly<PatchedOrganization>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.patch(
    `http://localhost:8000/api/organization/${id}`,
    patchedOrganization,
    options,
  );
};

/**
 * Video file details
 */
export const organizationDestroy = <TData = AxiosResponse<void>>(
  id: string,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.delete(`http://localhost:8000/api/organization/${id}`, options);
};

/**
 * Video events schedule

Query parameters
----------------

`date` - Date expressed in the format YYYY-MM-DD (eg. 2020-12-31), or
         "today".  Default is today, Europe/Oslo time.

`days` - Number of days schedule requested. Default is 7 days.

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`surrounding` - Fetch the first event before and after the given
                period

`ordering` - Order results by specified field.  Prepend a minus for
             descending order.  I.e. `?ordering=-starttime`.
 */
export const scheduleitemsList = <
  TData = AxiosResponse<PaginatedScheduleitemReadList>,
>(
  params?: ScheduleitemsListParams,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/scheduleitems/`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

/**
 * Video events schedule

Query parameters
----------------

`date` - Date expressed in the format YYYY-MM-DD (eg. 2020-12-31), or
         "today".  Default is today, Europe/Oslo time.

`days` - Number of days schedule requested. Default is 7 days.

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`surrounding` - Fetch the first event before and after the given
                period

`ordering` - Order results by specified field.  Prepend a minus for
             descending order.  I.e. `?ordering=-starttime`.
 */
export const scheduleitemsCreate = <TData = AxiosResponse<ScheduleitemModify>>(
  scheduleitemModify: NonReadonly<ScheduleitemModify>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(
    `http://localhost:8000/api/scheduleitems/`,
    scheduleitemModify,
    options,
  );
};

/**
 * Schedule item details
 */
export const scheduleitemsRetrieve = <TData = AxiosResponse<ScheduleitemRead>>(
  id: string,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/scheduleitems/${id}`, options);
};

/**
 * Schedule item details
 */
export const scheduleitemsUpdate = <TData = AxiosResponse<ScheduleitemModify>>(
  id: string,
  scheduleitemModify: NonReadonly<ScheduleitemModify>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.put(
    `http://localhost:8000/api/scheduleitems/${id}`,
    scheduleitemModify,
    options,
  );
};

/**
 * Schedule item details
 */
export const scheduleitemsPartialUpdate = <
  TData = AxiosResponse<ScheduleitemRead>,
>(
  id: string,
  patchedScheduleitemRead: NonReadonly<PatchedScheduleitemRead>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.patch(
    `http://localhost:8000/api/scheduleitems/${id}`,
    patchedScheduleitemRead,
    options,
  );
};

/**
 * Schedule item details
 */
export const scheduleitemsDestroy = <TData = AxiosResponse<void>>(
  id: string,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.delete(`http://localhost:8000/api/scheduleitems/${id}`, options);
};

/**
 * OpenApi3 schema for this API. Format can be selected via content negotiation.

- YAML: application/vnd.oai.openapi
- JSON: application/vnd.oai.openapi+json
 */
export const schemaRetrieve = <
  TData = AxiosResponse<
    | SchemaRetrieve200One
    | SchemaRetrieve200Two
    | SchemaRetrieve200Three
    | SchemaRetrieve200Four
  >,
>(
  params?: SchemaRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/schema/`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

/**
 * OpenApi3 schema for this API. Format can be selected via content negotiation.

- YAML: application/vnd.oai.openapi
- JSON: application/vnd.oai.openapi+json
 */
export const schemaFormattedRetrieve = <
  TData = AxiosResponse<
    | SchemaFormattedRetrieve200One
    | SchemaFormattedRetrieve200Two
    | SchemaFormattedRetrieve200Three
    | SchemaFormattedRetrieve200Four
  >,
>(
  format: ".json",
  params?: SchemaFormattedRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/schema${format}`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

/**
 * User details - used to manage your own user
 */
export const userRetrieve = <TData = AxiosResponse<User>>(
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/user`, options);
};

/**
 * User details - used to manage your own user
 */
export const userUpdate = <TData = AxiosResponse<User>>(
  user: NonReadonly<User>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.put(`http://localhost:8000/api/user`, user, options);
};

/**
 * User details - used to manage your own user
 */
export const userPartialUpdate = <TData = AxiosResponse<User>>(
  patchedUser: NonReadonly<PatchedUser>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.patch(`http://localhost:8000/api/user`, patchedUser, options);
};

/**
 * User details - used to manage your own user
 */
export const userDestroy = <TData = AxiosResponse<void>>(
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.delete(`http://localhost:8000/api/user`, options);
};

export const userLoginCreate = <TData = AxiosResponse<void>>(
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`http://localhost:8000/api/user/login`, undefined, options);
};

export const userLogoutCreate = <TData = AxiosResponse<void>>(
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(
    `http://localhost:8000/api/user/logout`,
    undefined,
    options,
  );
};

export const userRegisterCreate = <TData = AxiosResponse<NewUser>>(
  newUser: NonReadonly<NewUser>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(
    `http://localhost:8000/api/user/register`,
    newUser,
    options,
  );
};

/**
 * Video file list

Query parameters
----------------

HTTP parameters:

`video_id` - The (parent) video by ID

`created_time` - when this file entry was created.

`format__fsname` - the fileformat fsname for this file.

`integrated_lufs` (includes __gt, __gte, __lt, __lte, __isnull) the overall loudness of the file.

`truepeak_lufs` (includes __gt, __gte, __lt, __lte, __isnull) the overall loudness of the file.

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - Order results by specified field.  Prepend a minus for
             descending order.  I.e. `?ordering=-starttime`.
 */
export const videofilesList = <TData = AxiosResponse<PaginatedVideoFileList>>(
  params?: VideofilesListParams,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/videofiles/`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

/**
 * Video file list

Query parameters
----------------

HTTP parameters:

`video_id` - The (parent) video by ID

`created_time` - when this file entry was created.

`format__fsname` - the fileformat fsname for this file.

`integrated_lufs` (includes __gt, __gte, __lt, __lte, __isnull) the overall loudness of the file.

`truepeak_lufs` (includes __gt, __gte, __lt, __lte, __isnull) the overall loudness of the file.

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - Order results by specified field.  Prepend a minus for
             descending order.  I.e. `?ordering=-starttime`.
 */
export const videofilesCreate = <TData = AxiosResponse<VideoFile>>(
  videoFile: NonReadonly<VideoFile>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(
    `http://localhost:8000/api/videofiles/`,
    videoFile,
    options,
  );
};

/**
 * Video file details
 */
export const videofilesRetrieve = <TData = AxiosResponse<VideoFile>>(
  id: string,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/videofiles/${id}`, options);
};

/**
 * Video file details
 */
export const videofilesUpdate = <TData = AxiosResponse<VideoFile>>(
  id: string,
  videoFile: NonReadonly<VideoFile>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.put(
    `http://localhost:8000/api/videofiles/${id}`,
    videoFile,
    options,
  );
};

/**
 * Video file details
 */
export const videofilesPartialUpdate = <TData = AxiosResponse<VideoFile>>(
  id: string,
  patchedVideoFile: NonReadonly<PatchedVideoFile>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.patch(
    `http://localhost:8000/api/videofiles/${id}`,
    patchedVideoFile,
    options,
  );
};

/**
 * Video file details
 */
export const videofilesDestroy = <TData = AxiosResponse<void>>(
  id: string,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.delete(`http://localhost:8000/api/videofiles/${id}`, options);
};

/**
 * List of videos

Query parameters
----------------

`q` - Free search query.

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - Order results by specified field.  Prepend a minus for
             descending order.  I.e. `?ordering=-id`.

`creator__email` - the email of the video's creator

`framerate` - the framerate in hz * 1000

`has_tono_records` - if the tono flag is set (true/false)

`is_filler` - if this is a filler video (true/false)

`name` - the exact name/title of the video

`name__icontains` - substring is part of name/title of the video

`organization` - Frikanalen ID of organization behind video

`played_count_web` - the number of times this video was played on the web

`played_count_web__gt` - greater than

`played_count_web__gte` - greater than or equal

`played_count_web__lt`  - less than

`played_count_web__lte` - less than or equal

`publish_on_web` - if this video is published ont the web (true/false)

`proper_import` - if the uploaded video was properly imported (true/false)

`ref_url` - the exact reference url

`ref_url__startswith` - the reference url start with this string

`ref_url__icontains` - the reference url contain this string
 */
export const videosList = <TData = AxiosResponse<PaginatedVideoList>>(
  params?: VideosListParams,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/videos/`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

/**
 * List of videos

Query parameters
----------------

`q` - Free search query.

`page_size` - How many items per page. If set to 0 it will list
              all items.  Default is 50 items.

`ordering` - Order results by specified field.  Prepend a minus for
             descending order.  I.e. `?ordering=-id`.

`creator__email` - the email of the video's creator

`framerate` - the framerate in hz * 1000

`has_tono_records` - if the tono flag is set (true/false)

`is_filler` - if this is a filler video (true/false)

`name` - the exact name/title of the video

`name__icontains` - substring is part of name/title of the video

`organization` - Frikanalen ID of organization behind video

`played_count_web` - the number of times this video was played on the web

`played_count_web__gt` - greater than

`played_count_web__gte` - greater than or equal

`played_count_web__lt`  - less than

`played_count_web__lte` - less than or equal

`publish_on_web` - if this video is published ont the web (true/false)

`proper_import` - if the uploaded video was properly imported (true/false)

`ref_url` - the exact reference url

`ref_url__startswith` - the reference url start with this string

`ref_url__icontains` - the reference url contain this string
 */
export const videosCreate = <TData = AxiosResponse<VideoCreate>>(
  videoCreate: NonReadonly<VideoCreate>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`http://localhost:8000/api/videos/`, videoCreate, options);
};

/**
 * Video details
 */
export const videosRetrieve = <TData = AxiosResponse<Video>>(
  id: string,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(`http://localhost:8000/api/videos/${id}`, options);
};

/**
 * Video details
 */
export const videosUpdate = <TData = AxiosResponse<Video>>(
  id: string,
  video: NonReadonly<Video>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.put(`http://localhost:8000/api/videos/${id}`, video, options);
};

/**
 * Video details
 */
export const videosPartialUpdate = <TData = AxiosResponse<Video>>(
  id: string,
  patchedVideo: NonReadonly<PatchedVideo>,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.patch(
    `http://localhost:8000/api/videos/${id}`,
    patchedVideo,
    options,
  );
};

/**
 * Video details
 */
export const videosDestroy = <TData = AxiosResponse<void>>(
  id: string,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.delete(`http://localhost:8000/api/videos/${id}`, options);
};

/**
 * Video details
 */
export const videosUploadTokenRetrieve = <
  TData = AxiosResponse<VideoUploadToken>,
>(
  id: string,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.get(
    `http://localhost:8000/api/videos/${id}/upload_token`,
    options,
  );
};

export type RootRetrieveResult = AxiosResponse<void>;
export type AsrunListResult = AxiosResponse<PaginatedAsRunList>;
export type AsrunCreateResult = AxiosResponse<AsRun>;
export type AsrunRetrieveResult = AxiosResponse<AsRun>;
export type AsrunUpdateResult = AxiosResponse<AsRun>;
export type AsrunPartialUpdateResult = AxiosResponse<AsRun>;
export type AsrunDestroyResult = AxiosResponse<void>;
export type CategoriesListResult = AxiosResponse<PaginatedCategoryList>;
export type CategoriesCreateResult = AxiosResponse<Category>;
export type CategoriesRetrieveResult = AxiosResponse<Category>;
export type CategoriesUpdateResult = AxiosResponse<Category>;
export type CategoriesPartialUpdateResult = AxiosResponse<Category>;
export type CategoriesDestroyResult = AxiosResponse<void>;
export type JukeboxCsvRetrieveResult = AxiosResponse<void>;
export type NewsBulletinsListResult = AxiosResponse<Bulletin[]>;
export type NewsBulletinsCreateResult = AxiosResponse<Bulletin>;
export type NewsBulletinsRetrieveResult = AxiosResponse<Bulletin>;
export type NewsBulletinsUpdateResult = AxiosResponse<Bulletin>;
export type NewsBulletinsPartialUpdateResult = AxiosResponse<Bulletin>;
export type NewsBulletinsDestroyResult = AxiosResponse<void>;
export type ObtainTokenRetrieveResult = AxiosResponse<Token>;
export type OrganizationListResult = AxiosResponse<PaginatedOrganizationList>;
export type OrganizationCreateResult = AxiosResponse<Organization>;
export type OrganizationRetrieveResult = AxiosResponse<Organization>;
export type OrganizationUpdateResult = AxiosResponse<Organization>;
export type OrganizationPartialUpdateResult = AxiosResponse<Organization>;
export type OrganizationDestroyResult = AxiosResponse<void>;
export type ScheduleitemsListResult =
  AxiosResponse<PaginatedScheduleitemReadList>;
export type ScheduleitemsCreateResult = AxiosResponse<ScheduleitemModify>;
export type ScheduleitemsRetrieveResult = AxiosResponse<ScheduleitemRead>;
export type ScheduleitemsUpdateResult = AxiosResponse<ScheduleitemModify>;
export type ScheduleitemsPartialUpdateResult = AxiosResponse<ScheduleitemRead>;
export type ScheduleitemsDestroyResult = AxiosResponse<void>;
export type SchemaRetrieveResult = AxiosResponse<
  | SchemaRetrieve200One
  | SchemaRetrieve200Two
  | SchemaRetrieve200Three
  | SchemaRetrieve200Four
>;
export type SchemaFormattedRetrieveResult = AxiosResponse<
  | SchemaFormattedRetrieve200One
  | SchemaFormattedRetrieve200Two
  | SchemaFormattedRetrieve200Three
  | SchemaFormattedRetrieve200Four
>;
export type UserRetrieveResult = AxiosResponse<User>;
export type UserUpdateResult = AxiosResponse<User>;
export type UserPartialUpdateResult = AxiosResponse<User>;
export type UserDestroyResult = AxiosResponse<void>;
export type UserLoginCreateResult = AxiosResponse<void>;
export type UserLogoutCreateResult = AxiosResponse<void>;
export type UserRegisterCreateResult = AxiosResponse<NewUser>;
export type VideofilesListResult = AxiosResponse<PaginatedVideoFileList>;
export type VideofilesCreateResult = AxiosResponse<VideoFile>;
export type VideofilesRetrieveResult = AxiosResponse<VideoFile>;
export type VideofilesUpdateResult = AxiosResponse<VideoFile>;
export type VideofilesPartialUpdateResult = AxiosResponse<VideoFile>;
export type VideofilesDestroyResult = AxiosResponse<void>;
export type VideosListResult = AxiosResponse<PaginatedVideoList>;
export type VideosCreateResult = AxiosResponse<VideoCreate>;
export type VideosRetrieveResult = AxiosResponse<Video>;
export type VideosUpdateResult = AxiosResponse<Video>;
export type VideosPartialUpdateResult = AxiosResponse<Video>;
export type VideosDestroyResult = AxiosResponse<void>;
export type VideosUploadTokenRetrieveResult = AxiosResponse<VideoUploadToken>;
